{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This repository contains the code and report for the \"Social Network Analysis\" course at Alma Mater Studiorum University of Bologna.</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Matteo Fasulo</li> <li>Luca Babboni</li> <li>Maksim Omelchenko</li> <li>Francesca Bertoglio</li> </ul>"},{"location":"#report","title":"Report","text":"<p>The PDF report is available here.</p>"},{"location":"#abstract","title":"Abstract","text":"<p>In recent decades, analyzing the robustness of Public Transport Networks (PTNs) has become increasingly critical for ensuring their reliability and efficiency. As urban populations grow and transportation systems become more interconnected, understanding the resilience of PTNs to disruptions is essential for effective planning, optimization, and sustainable development. Complex network theory provides a powerful framework for investigating the structural and functional properties of spatial networks like PTNs, offering insights into their vulnerability and capacity to withstand failures.</p> <p>Our analysis examines the multilayer PTN of Milan, Italy, focusing on three key aspects:  1. the spatial distribution of centrality measures, specifically betweenness centrality (BC) and closeness centrality (CC) 2. the small-worldness properties of the network 3. its robustness through what-if scenarios simulating node removal.</p> <p>These features help identify critical nodes that underpin the network's resilience. The network comprises three interconnected layers: metro, tram, and bus systems. Each layer is represented as a graph in L-space topology [1], where stops and stations are nodes, and their connections are edges (e.g., a bus traveling between two stops). Data for this study were sourced from Open Street Map, and the full analysis, including a Python notebook, is publicly available in this repo</p>"},{"location":"#dataset","title":"Dataset","text":"<p>Using data from OpenStreetMap (OSM), we construct the metro, tram and bus networks for Milan (Italy). We downloaded data in geo-referenced vectorial format from Open Street Map under the Open Database License (ODbL) v1.0. Specifically, the datasets were extracted using the Overpass Turbo tool by invoking its API. All data used in this study is publicly available, ensuring transparency and accessibility.</p> <p>For storage and manipulation, the data was structured as a graph using the NetworkX library, a Python package designed for creating, analyzing, and visualizing complex networks. NetworkX offers a rich suite of tools for computing various graph measures and performing network analysis. Additionally, other Python libraries, such as OSMnx and GeoPandas, were employed to streamline the processing pipeline and enhance code readability while maintaining high development efficiency. In addition, a series of automatic and manual topological cleaning operations were neeeded in order to extract consistent and usable graphs.</p> <p>Three distinct datasets were collected for this study, representing different modes of public transport in Milan: metro, tram, and bus (including both stops and routes). Of these, the bus dataset is the most complex due to the extensive network. For consistency and relevance, only bus stops operated by Azienda Trasporti Milanesi S.p.A (ATM) were included. </p> <p>The datasets were further categorized as follows:</p> Layer N M Lines Metro 125 258 5 Tram 308 680 17 Bus 1370 3788 113"},{"location":"#references","title":"References","text":"<ul> <li>[1] Sen et al, \"Small-world properties of the Indian railway network\", Mar/2023, American Physical Society, doi=10.1103/PhysRevE.67.036106, url=https://link.aps.org/doi/10.1103/PhysRevE.67.036106</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"1-osm/","title":"OpenStreetMap","text":"<p>Using data from OpenStreetMap (OSM), we construct the metro, tram and bus networks for Milan (Italy). We downloaded data in geo-referenced vectorial format from Open Street Map under the Open Database License (ODbL) v1.0. Specifically, the datasets were extracted using the Overpass Turbo tool by invoking its API. All data used in this study is publicly available, ensuring transparency and accessibility.</p>"},{"location":"1-osm/#query","title":"Query","text":"<p>The following query in Overpass QL format was used to extract the data for Milan public transport system:</p> osmgraph.py<pre><code>[out:json]\n[timeout:30];\narea[\"name:en\"=\"Milan\"]-&gt;.searchArea;\nrelation[\"type\"=\"route\"][\"route\"=\"bus\"][\"operator\"=\"ATM\"](area.searchArea);\nrelation[\"type\"=\"route\"][\"route\"=\"tram\"](area.searchArea);\nrelation[\"type\"=\"route\"][\"route\"=\"subway\"](area.searchArea);\nout meta;\n&gt;;\nout body;\n</code></pre>"},{"location":"1-osm/#data-processing","title":"Data Processing","text":"<p>We have extracted the route elements from the OSM data using the following tags:</p> osmgraph.py<pre><code>def get_route_elements(self, osm_data: dict) -&gt; List[dict]:\n    \"\"\"\n    Extracts route elements from OpenStreetMap (OSM) data.\n\n    This method filters the elements in the provided OSM data to return only those\n    that have a 'tags' key and contain a 'route' key within the 'tags' dictionary.\n\n    Args:\n        osm_data (dict): A dictionary containing OSM data, which includes a list of elements.\n\n    Returns:\n        list: A list of elements that have a 'tags' key and contain a 'route' key within the 'tags' dictionary.\n    \"\"\"\n    return [element for element in osm_data['elements'] if 'tags' in element and 'route' in element['tags']]\n</code></pre> <p>And for the nodes:</p> osmgraph.py<pre><code>def get_node_elements(self, osm_data: dict) -&gt; dict:\n    \"\"\"\n    Extracts and returns node elements from OpenStreetMap (OSM) data.\n\n    Args:\n        osm_data (dict): A dictionary containing OSM data, where 'elements' is a key \n                            that holds a list of elements, each being a dictionary with \n                            various attributes including 'id' and 'type'.\n\n    Returns:\n        dict: A dictionary where the keys are the IDs of the node elements and the \n                values are the corresponding element dictionaries.\n    \"\"\"\n    return {element['id']: element for element in osm_data['elements'] if element['type'] == 'node'}\n</code></pre> <p>the main algorithm for creating the graph is as follows:</p> osmgraph.py<pre><code>def get_graph(self, simplify: bool = False, *args, **kwargs) -&gt; nx.Graph:\n    \"\"\"\n    Generate a graph representation of the OpenStreetMap (OSM) data.\n    Parameters:\n    simplify (bool): If True, the graph will be simplified using the simplify_graph method. Default is False.\n    *args: Additional positional arguments to pass to the simplify_graph method.\n    **kwargs: Additional keyword arguments to pass to the simplify_graph method.\n    Returns:\n    networkx.Graph: A NetworkX graph object representing the OSM data.\n    The method performs the following steps:\n    1. Instantiates a Graph.\n    2. Retrieves OSM data using the get_data method.\n    3. Extracts route elements and node elements from the OSM data.\n    4. Adds nodes and edges to the graph based on the route and node elements.\n    5. Sets the graph's coordinate reference system (CRS) to 'EPSG:3857'.\n    6. Optionally simplifies the graph if the simplify parameter is True.\n    7. Stores the generated graph in the instance variable self.G and returns it.\n    \"\"\"\n    # Instantiate a Graph\n    G = nx.Graph()\n\n    # Get the data\n    osm_data = self.get_data()\n\n    # Get the routes\n    route_elements = self.get_route_elements(osm_data)\n    # Get the nodes\n    node_elements = self.get_node_elements(osm_data)\n\n    # Add nodes and edges\n    for route in route_elements:\n        stop_nodes = [member for member in route['members'] if member['role'] == 'stop']\n\n        # Add nodes\n        for node in stop_nodes:\n            ref = node['ref']\n            if ref in node_elements:\n                node_data = node_elements[ref]\n                node_tags = node_data.get('tags', {})\n                name = node_tags.get('name', str(ref))\n                line = route['tags'].get('ref', 'Unknown')\n\n                G.add_node(node_for_adding=ref, id=node_data['id'], osmid=node_data['id'], pos=(node_data['lon'], node_data['lat']), x=node_data['lon'], y=node_data['lat'], name=name, line=line, layer_name=self.kind)\n\n        # Add edges between consecutive stop nodes\n        for i in range(len(stop_nodes) - 1):\n            if stop_nodes[i]['ref'] in node_elements and stop_nodes[i+1]['ref'] in node_elements: #should avoid to add nodes with no data\n                G.add_edge(u_of_edge=stop_nodes[i]['ref'], v_of_edge=stop_nodes[i+1]['ref'], **route['tags'], layer_name=self.kind)\n\n    G.graph = {'crs': self.crs} # TODO: Check if this is the appropriate CRS\n\n    if simplify:\n        G = self.simplify_graph(G, *args, **kwargs)\n\n    self.G = G\n\n    # Add edge length attribute\n    G = self.add_edge_lengths(G)\n\n    self.G = G\n    return G\n</code></pre>"},{"location":"1-osm/#simplification-of-the-graph","title":"Simplification of the Graph","text":"<p>Since the raw data extracted from OSM can be quite detailed and contain redundant information, we provide a method to simplify the graph by clustering nodes within a certain distance threshold and creating new edges between the cluster centers. This process reduces the complexity of the graph while preserving its essential structure. The nodes within each cluster are merged into a single representative node, and the edges are updated accordingly.</p> <p>In order to find the clusters of nodes that are close to each other, we use the DBSCAN clustering algorithm, which groups together nodes that are within a specified distance threshold. The distance threshold is given in meters and determines the maximum distance between two nodes for them to be considered part of the same cluster. Then a constant factor is used to convert the distance threshold from meters to a suitable range for the clustering algorithm parameter (epsilon).</p> <p>The simplification algorithm is as follows:</p> osmgraph.py<pre><code>def simplify_graph(self, G: nx.Graph, distance_threshold: int = 50, verbose: bool = False) -&gt; nx.Graph:\n    \"\"\"\n    Simplifies the given graph by merging nodes that are within a specified distance threshold.\n    Parameters:\n    G (networkx.Graph): The input graph to be simplified.\n    distance_threshold (int, optional): The distance threshold in meters for merging nodes. Default is 50.\n    verbose (bool, optional): If True, prints additional information during processing. Default is False.\n    Returns:\n    networkx.Graph: The simplified graph with merged nodes.\n    Notes:\n    - The function uses DBSCAN clustering to group nodes that are within the distance threshold.\n    - Nodes within the same cluster are merged into a single node, with the position updated to the centroid of the cluster.\n    - The primary node for each cluster is chosen as the node with the smallest ID.\n    - The position of the primary node is updated to the centroid of the cluster.\n    \"\"\"\n    # Extract positions and corresponding node IDs\n    positions = np.array([G.nodes[node]['pos'] for node in G.nodes()])\n    node_ids = list(G.nodes())\n\n    # Perform DBSCAN clustering\n    db = DBSCAN(eps=distance_threshold / 1e5, min_samples=1).fit(positions)  # Convert meters to kilometers if needed\n\n    # Create a mapping from cluster label to node IDs\n    cluster_map = {}\n    for idx, label in enumerate(db.labels_):\n        if label not in cluster_map:\n            cluster_map[label] = []\n        cluster_map[label].append(node_ids[idx])\n\n    print(\"Found\", len(cluster_map), \"clusters.\")\n    # Merge nodes based on clusters\n    count = 0\n    for cluster_nodes in tqdm(cluster_map.values(), desc='Merging nodes', disable=not verbose):\n        if len(cluster_nodes) &lt; 2:\n            continue\n\n        centroid_position = self.centroid([G.nodes[node]['pos'] for node in cluster_nodes])\n        primary_node = min(cluster_nodes)  # Choose one node as primary\n\n        for node in cluster_nodes:\n            if node != primary_node:\n                G = nx.contracted_nodes(G, primary_node, node, self_loops=False)\n\n        # Update position of primary node to centroid position\n        G.nodes[primary_node]['pos'] = centroid_position\n        G.nodes[primary_node]['x'], G.nodes[primary_node]['y'] = centroid_position\n\n        count += 1\n\n    if verbose:\n        print(f'Merged {count} clusters into centroids.')\n\n    return G\n</code></pre>"}]}